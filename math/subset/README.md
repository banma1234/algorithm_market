## DFS 이용한 부분집합 구하기

부분집합의 경우의 수를 `DFS` 탐색 알고리즘을 활용해 구한다. `subset` 배열의 원소가 `1`인 경우 해당 원소의 index값에 해당하는 수를 부분집합의 원소로 판별한다.

`DFS`는 `재귀함수`를 이용해 구현한다. `스택(stack)` 자료형을 활용하는 것이 일반적이나 PC에서 함수의 콜스택을 스택을 이용해 관리하므로 재귀함수를 이용하더라도 문제없다.

---

x(=1) ~ y(=3)까지의 부분집합을 구하는 상황을 가정하고 코드의 흐름을 파악해본다.

결과값을 담을 `result` 배열과 부분집합 판별을 위한 y+1 크기의 `subset` 배열을 준비하고 첫번째 값인 `x(=1)`를 DFS(num)의 파라미터로 제공한다.

DFS가 호출되면 다음과 같은 로직을 거친다.

- `num`이 `y`보다 작거나 같은경우
  - subset[num]의 값을 `1`로 초기화하고 `DFS(num + 1)`을 DFS `내부`에서 호출한다. 즉 subset[1] = 1이 되고 DFS(2)가 호출된다.
  - DFS(2)의 파라미터 `2` 또한 `y`보다 작으므로 subset[2] = 1이 되고 DFS(3)이 호출된다.
  - DFS(3)의 파라미터 `3`은 `y`와 같으므로 subset[3] = 1이 되고 DFS(4)가 호출된다. DFS(4)의 파라미터 `4`는 `y`보다 크기 때문에 호출시 부분집합을 계산하는 로직으로 들어가게 된다.
- `num`이 `y`보다 큰 경우
  - for문을 이용해 y+1만큼 반복하며 subset[i]의 원소를 검사한다.
  - subset[i] === 1일 경우 `i`의 값은 부분집합의 원소로 볼 수 있다. 이번의 경우 subset = [0, 1, 1, 1]이기 때문에 `1`, `2`, `3`이 부분집합의 원소로 판별된다.
  - 해당 값을 `result`에 push하는것으로 함수를 종료한다.

DFS(4)가 부분집합의 원소를 result에 push하는 것으로 종료되었기 때문에 PC의 함수 콜스택에서 DFS(4)는 pop되며 DFS(4)를 호출한 함수 DFS(3)로 돌아가게 된다. 돌아온 이후 subset[num] = `0`으로 초기화 하고 DFS(num + 1)을 호출하고 함수를 종료한다. 돌아온 곳이 DFS(3) 이므로 subset[3] = 0이 되고 DFS(4)가 호출된다.

- `num`이 `y`보다 큰 경우
  - 마찬가지로 반복하며 subset[i]를 검사한다.
  - 현재 subset = [0, 1, 1, 0]이므로 `1`, `2`가 부분집합의 원소로 판별되어 `result`에 push하고 함수를 종료한다.

또다시 DFS(4)가 종료되고 DFS(3)으로 돌아왔으나 곧바로 함수가 종료되기 때문에 다시 DFS(3)을 호출한 DFS(2)로 돌아와 subset[2] = 0, DFS(3)을 호출한다.

- `num`이 `y`보다 작거나 같은경우

  - DFS(3)의 파라미터 `3`이 `y`보다 작기 때문에 subset[3] = 1, DFS(4)를 호출한다.

- `num`이 `y`보다 큰 경우
  - 마찬가지로 반복하며 subset[i]를 검사한다.
  - 현재 subset = [0, 1, 0, 1]이므로 `1`, `3`이 부분집합의 원소로 판별되어 `result`에 push하고 함수를 종료한다.

위 과정이 반복되면 끝에는 부분집합의 원소를 담은 배열 `result`만이 남게 된다.

```javascript
console.log(subset(1, 3));
// (7) ['1 2 3', '1, 2', '1, 3', '1', '2, 3', '2', '3']
```

---

### 소스코드

```javascript
function subset(x, y) {
  const result = [];
  const subset = Array(y + 1).fill(0);

  function DFS(num) {
    if (num > y) {
      let tmp = "";
      for (let i = 0; i < y + 1; i++) {
        if (subset[i] === 1) {
          tmp += i + " ";
        }
      }
      if (tmp != "") result.push(tmp.trim());
    } else {
      subset[num] = 1;
      DFS(num + 1);
      subset[num] = 0;
      DFS(num + 1);
    }
  }

  DFS(x);
  return result;
}
}
```
